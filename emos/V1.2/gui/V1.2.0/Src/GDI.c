#include "GDI.h"
#include "string.h" 
#include "lcd_init.h"

#define ASCIIFontAddr 		0x80A0000			//英文字库地址
#define GBFontAddr 				0x80C0000			//国标字库地址

u8 DispBuff[128][120];
static const u8 m_arrSmallNumber[] = {
	0x00,0x00,0x00,0x30,0x48,0x84,0x84,0x84,0x84,0x84,0x48,0x30,0x00,0x00,/*"0",0*/
	0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,/*"1",1*/
	0x00,0x00,0x00,0x38,0x44,0x44,0x04,0x08,0x10,0x20,0x44,0x7C,0x00,0x00,/*"2",2*/	
	0x00,0x00,0x00,0x38,0x44,0x44,0x18,0x04,0x04,0x44,0x44,0x38,0x00,0x00,/*"3",3*/	
	0x00,0x00,0x08,0x08,0x18,0x28,0x48,0x48,0x88,0x7C,0x08,0x1C,0x00,0x00,/*"4",4*/	
	0x00,0x00,0x00,0x7C,0x40,0x40,0x78,0x44,0x04,0x44,0x44,0x38,0x00,0x00,/*"5",5*/	
	0x00,0x00,0x00,0x3C,0x44,0x80,0xB8,0xC4,0x84,0x84,0x84,0x78,0x00,0x00,/*"6",6*/	
	0x00,0x00,0x00,0x7C,0x44,0x48,0x08,0x10,0x10,0x10,0x10,0x10,0x00,0x00,/*"7",7*/	
	0x00,0x00,0x00,0x78,0x84,0x84,0x48,0x78,0x84,0x84,0x84,0x78,0x00,0x00,/*"8",8*/	
	0x00,0x00,0x00,0x78,0x84,0x84,0x84,0x8C,0x74,0x04,0x88,0xF0,0x00,0x00,/*"9",9*/
	0x00,0x00,0x00,0x44,0xA8,0xA8,0xB0,0x54,0x1A,0x2A,0x2A,0x44,0x00,0x00,/*"%",0*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,/*"."*/	
	0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"-"*/	
	0x00,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x0C,0x00,0x00/*"t"*/
};

static const u8 m_arrBigNumber30[] = 
// 0(0) 1(1) 2(2) 3(3) 4(4) 5(5) 6(6) 7(7) 8(8) 9(9) .(10) -(11) t(12)
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,
0x0E,0x60,0x1C,0x30,0x38,0x38,0x38,0x38,0x30,0x1C,0x70,0x1C,0x70,0x1C,
0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x30,0x18,
0x38,0x38,0x38,0x38,0x1C,0x70,0x0E,0x60,0x07,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"0",0*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0x01,0xC0,0x0F,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,
0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,
0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x0F,0xF8,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"1",1*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,
0x0C,0x78,0x18,0x38,0x30,0x1C,0x30,0x1C,0x38,0x1C,0x38,0x1C,0x00,0x18,
0x00,0x38,0x00,0x70,0x00,0x60,0x00,0xC0,0x01,0x80,0x03,0x00,0x06,0x00,
0x0C,0x0C,0x18,0x0C,0x30,0x1C,0x3F,0xFC,0x3F,0xF8,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"2",2*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,
0x1C,0xF0,0x38,0x70,0x38,0x38,0x38,0x38,0x38,0x38,0x00,0x38,0x00,0x70,
0x00,0xE0,0x03,0xC0,0x00,0x70,0x00,0x38,0x00,0x1C,0x00,0x1C,0x38,0x1C,
0x38,0x1C,0x38,0x1C,0x38,0x38,0x18,0x70,0x0F,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"3",3*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x70,
0x00,0xF0,0x00,0xF0,0x01,0xF0,0x03,0x70,0x03,0x70,0x06,0x70,0x0C,0x70,
0x0C,0x70,0x18,0x70,0x18,0x70,0x30,0x70,0x60,0x70,0x3F,0xFC,0x00,0x70,
0x00,0x70,0x00,0x70,0x00,0x70,0x00,0xF0,0x03,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"4",4*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFC,
0x0F,0xFC,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x1B,0xE0,
0x1E,0x78,0x1C,0x38,0x18,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x38,0x1C,
0x38,0x1C,0x38,0x38,0x30,0x38,0x18,0x70,0x0F,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"5",5*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,
0x0E,0x38,0x1C,0x38,0x18,0x38,0x38,0x00,0x30,0x00,0x70,0x00,0x77,0xE0,
0x7E,0x70,0x78,0x38,0x78,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,
0x30,0x1C,0x38,0x18,0x1C,0x38,0x1E,0x70,0x07,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"6",6*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFC,
0x1F,0xFC,0x38,0x18,0x30,0x30,0x30,0x30,0x00,0x60,0x00,0x60,0x00,0xC0,
0x00,0xC0,0x01,0x80,0x01,0x80,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,
0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"7",7*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xE0,
0x3C,0x78,0x38,0x38,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x78,0x1C,0x3C,0x38,
0x1F,0x70,0x0F,0xC0,0x1D,0xF0,0x38,0x78,0x30,0x38,0x70,0x1C,0x70,0x1C,
0x70,0x1C,0x70,0x1C,0x38,0x38,0x1C,0x70,0x0F,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"8",8*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xC0,
0x1C,0x70,0x38,0x38,0x70,0x38,0x70,0x18,0x70,0x1C,0x70,0x1C,0x70,0x1C,
0x70,0x3C,0x38,0x3C,0x3C,0xFC,0x0F,0xDC,0x00,0x1C,0x00,0x38,0x00,0x38,
0x00,0x38,0x38,0x70,0x38,0x70,0x38,0xE0,0x1F,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"9",9*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x1C,0x00,0x3E,0x00,0x3E,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*".",10*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"-",11*/
/* (15 X 30 , 宋体, 加粗 )*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x07,0x00,0x0F,0x00,0x7F,0xF0,
0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,0x07,0x00,
0x07,0x00,0x07,0x18,0x07,0x18,0x03,0xB0,0x03,0xE0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,/*"t",12*/
/* (15 X 30 , 宋体, 加粗 )*/
};


static s16 m_cxScreen = 240;							    //定义屏幕宽度(单位为像素)
static s16 m_cyScreen = 128;								//定义屏幕高度(单位为像素)

static s16 m_ViewPosX = 0;								//视图水平起点
static s16 m_ViewPosY = 0;								//视图垂直起点
static s16 m_ViewSizeX = 240;								//视图水平宽度
static s16 m_ViewSizeY = 128;								//视图垂直宽度
static u8 m_bUseView = 0;
									
static s16 m_nRedrawIndex = 0;
static u8	m_bScreenFlush = 1;
static u8 m_Color = 0x00;

#define GDI_MEM_ROW		128
#define GDI_MEM_COL		30
u8 GdiMem[GDI_MEM_ROW][GDI_MEM_COL];										//表示128×240屏的显存矩阵


#define MAKE_COLOR(x)	((x) ^ m_Color)
/****************************************************************************
* 名	称：u8 BeginPaint(void)
* 功	能：GUI初始化函数，包括对LCD的初始化
* 入口参数：无
* 出口参数：无
* 说	明：要使用LCD前必须调用该函数一次
****************************************************************************/	
extern LCD_Init(void);

void BeginPaint(void)
{
	LCD_Init();
	m_nRedrawIndex = 0;
	m_bScreenFlush = 1;	
}

void EnableGdiView(u8 bEnable)
{
	m_bUseView = bEnable;
}

void SetGdiView(s16 x, s16 y, s16 cx, s16 cy)
{
	m_ViewPosX = x;
	m_ViewPosY = y;
	m_ViewSizeX = cx;	
	m_ViewSizeY = cy;
}

void SetColor(u32 nColor)
{
	m_Color = (nColor == 0) ? 0 : 0xFF;
}

void InvertColor(void)
{
	//反转颜色
	m_Color = ~m_Color;
}

void EraseBuffer(void)
{
	memset((unsigned char *)DispBuff, MAKE_COLOR(0), sizeof(DispBuff));
}

void EraseRect(s16 x, s16 y, s16 cx, s16 cy)
{
	u8 OldColor = m_Color;
	SetColor(1);
	FillRect(x, y, cx, cy);
	SetColor(OldColor);
}

/****************************************************************************
* 名	称：void EraseScreen(void)
* 功	能：清屏及MCU上的显存
* 入口参数：无
* 出口参数：无
* 说	明：
****************************************************************************/	
void EraseScreen(void)
{
	ClearScreen();
	memset((unsigned char *)DispBuff, 0, sizeof(DispBuff));
}

//设置图形重绘
void SetRedraw(u8 bEnable)
{
	if (bEnable == 0) { 				//如果禁止重绘
		m_nRedrawIndex++;
		return;
	}
	if (m_nRedrawIndex > 0) {			//如果使能重绘
		m_nRedrawIndex--;
	}
	if (m_nRedrawIndex == 0)	{		//如果重绘被开启	
		LCD_WriteCommand(LCD_DIS_GON); 	//显示图像
	}
}

/*
 *	刷新整个窗口
 */
void LCD_SendBuffAll(unsigned char *ptr)
{
	int x = 0,y = 0;
	int width = 239;
	int high = 127;
	int i,j;
	
	SdCmd(0xf4); SdCmd(x);                   		// 设置操作窗口左边界
	SdCmd(0xf5); SdCmd(y);                   		// 设置操作窗口上边界 
	SdCmd(0xf6); SdCmd(width/3);             		// 设置操作窗口右边界
	SdCmd(0xf7); SdCmd(high);              			// 设置操作窗口下边界
	SdCmd(0xf8);		                    		// 设置窗口操作使能
	SdCmd(x&0x0f);SdCmd(0x10|(x>>4));        		// 设置起始列地址
	SdCmd(0x60+(y&0x0f)); SdCmd(0x70+(y>>4));		// 设置起始行地址	
	for (i = 0; i < 128; i++) {
		for (j = 0; j < 120; j++) {
			SdData(*ptr++);
		}
	}	
}
/*
 *	刷新指定窗口缓存
 */
void LCD_SendBuffDC(int x, int y, int xl, int yl)
{
	int i, j;
	int sx;
	int ex, ey;
	int mod, len;	
	
	mod = x % 6;				/* 计算距离上一个6倍数地址的距离 */
	x -= mod;					/* 计算距离上一个6倍数地址的距离 */
	sx = x / 3;					/* 计算液晶屏内的地址 */
	xl += mod;					/* 长度增加 */
	ex = (xl + x) - 1;			/* 将起始坐标和长度转换为结束坐标x */
	mod = ex % 6;				/* 计算结束地址的余数 */
	ex = ex + (6 - mod) - 1;	/* 算出x的结束地址，结束地址是6个倍数 */
	len = (ex + 1) / 2;			/* 从起始地址一直刷到结束地址 */		
 	ey = (yl + y) - 1;			/* 计算y轴的结束坐标 */
	SdCmd(0xf4); SdCmd(sx);                   		// 设置操作窗口左边界
	SdCmd(0xf5); SdCmd(y);                   		// 设置操作窗口上边界 
	SdCmd(0xf6); SdCmd(ex/3);             			// 设置操作窗口右边界
	SdCmd(0xf7); SdCmd(ey);              			// 设置操作窗口下边界
	SdCmd(0xf8);		                    		// 设置窗口操作使能
	SdCmd(sx&0x0f);SdCmd(0x10|(sx>>4));        		// 设置起始列地址
	SdCmd(0x60+(y&0x0f)); SdCmd(0x70+(y>>4));		// 设置起始行地址	
	for (i = y; i <= ey; i++) {
		for (j = x/2; j < len; j++) {
			SdData(DispBuff[i][j]);
		}
	}	
}

void Draw_ImageToDispBuff(int xpos, int ypos, int xlen, int ylen, const unsigned char *ptr)
{
	int i, j;
	int sx;
	int odd,num;
	unsigned char buff;
	unsigned char sbu;	
	
	sx = xpos;
	buff = *ptr;
	for (i = ypos; i < (ypos + ylen); i++) {			
		for (j = xpos; j < (xpos + xlen); j++) {
			if (((j - sx) % 8) == 0) {
				buff = *ptr++;
			}	
			num = (j / 2);
			odd = (j % 2);
			if (odd == 0) {											/* 如果余数为0表示在字节的高半字节 */
				sbu = DispBuff[i][num] & 0x0F;	
				if (buff & 0x80) {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] | 0xF0) & 0xF0) | (sbu);
				} else {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] & 0x0F) & 0xF0) | (sbu);
				}	
			} else {												/* 如果余数为1表示在字节的低半字节 */
				sbu = DispBuff[i][num] & 0xF0;
				if (buff & 0x80) {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] | 0x0F) & 0x0F) | (sbu);
				} else {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] & 0xF0) & 0x0F) | (sbu);
				}			
			}	
			buff <<= 1;
		}
	}	
}

void Draw_LineToDispBuff(int xpos, int ypos, int xlen, int ylen)
{
	int i, j;
	int sx;
	int odd,num;
	unsigned char buff;
	unsigned char sbu;	
	
	sx = xpos;
	buff = 0xFF;
	for (i = ypos; i < (ypos + ylen); i++) {			
		for (j = xpos; j < (xpos + xlen); j++) {
			if (((j - sx) % 8) == 0) {
				buff = 0xFF;
			}	
			num = (j / 2);
			odd = (j % 2);
			if (odd == 0) {											/* 如果余数为0表示在字节的高半字节 */
				sbu = DispBuff[i][num] & 0x0F;	
				if (buff & 0x80) {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] | 0xF0) & 0xF0) | (sbu);
				} else {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] & 0x0F) & 0xF0) | (sbu);
				}	
			} else {												/* 如果余数为1表示在字节的低半字节 */
				sbu = DispBuff[i][num] & 0xF0;
				if (buff & 0x80) {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] | 0x0F) & 0x0F) | (sbu);
				} else {
					DispBuff[i][num] = (MAKE_COLOR(DispBuff[i][num] & 0xF0) & 0x0F) | (sbu);
				}			
			}	
			buff <<= 1;
		}
	}	
}

void RefreshDC(s16 sx, s16 sy, s16 ex, s16 ey)
{
	//如果禁止刷屏则返回
	if (m_bScreenFlush == 0) return;

// 	if (m_nRedrawIndex == 0) {
// 		LCD_WriteCommand(LCD_DIS_GON); 
// 	} else {
// 		LCD_WriteCommand(LCD_DIS_OFF); 
// 	}			 

	LCD_SendBuffDC(sx, sy, ex, ey);
	
}

//使能禁止刷屏
void EnableScreenFlush(u8 bEnable)
{
	m_bScreenFlush = bEnable;	
}

//刷新整个屏幕
void FlushScreen(void)
{
	//开关显示
// 	if (m_nRedrawIndex == 0) {
// 		LCD_WriteCommand(LCD_DIS_GON); 
// 	} else {
// 		LCD_WriteCommand(LCD_DIS_OFF); 
// 	}
	
	LCD_SendBuffAll((unsigned char *)DispBuff);
}


void DrawGbChinesChar(char HiByte, char LoByte, s16 x, s16 y)
{
	//中文字库开始位置为0x80C0000

	u8* pMatrix = (u8*)((((HiByte | 0x80) - 0xA1) * 94 + ((LoByte | 0x80) - 0xA1)) * 28 + GBFontAddr);

	DrawImage(pMatrix, x, y, 14, 14);
}

void DrawGbAscChar(char Byte, s16 x, s16 y)
{
	//英文字库开始位置为0x80A0000

	u8* pMatrix = (u8*)(Byte * 14 + ASCIIFontAddr);

	DrawImage(pMatrix, x, y, 7, 14);

}

//文字输出
void DrawGbText(char *s, s16 x, s16 y) 
{
	while (*s != 0) {
		if ((*s & 0x80) == 0) {		//英文
			DrawGbAscChar(*s, x, y); 
			s += 1;
			x += 7;
		} else {					//中文	
			DrawGbChinesChar(*s, *(s+1), x, y);
			s += 2;
			x += 14;
		}
	}	 
}
/*
 *	刷一次指定屏
 */
void FlushRect(s16 x, s16 y, s16 cx, s16 cy)
{
	RefreshDC(x, y, cx, cy);					/* 将数据发送到LCD */
}

/*
 *	画实心矩形，单位为像素
 */
void FillRect(s16 x, s16 y, s16 cx, s16 cy)		 
{
	Draw_LineToDispBuff(x, y, cx, cy);			/* 画填充矩形 */
 	RefreshDC(x, y, cx, cy);					/* 将数据发送到LCD */
}
/*
 *	刷指定大小的一个图片
 */
void DrawImage(const u8* pImage, s16 x, s16 y, s16 cx, s16 cy)
{
	Draw_ImageToDispBuff(x, y, cx, cy, pImage);	/* 将数据些到显示缓存 */
	RefreshDC(x, y, cx, cy);					/* 将数据发送到LCD */
}

void DrawPoint(s16 x, s16 y)
{
	FillRect(x, y, 1, 1);
}

void DrawHoriLine(s16 x, s16 y, s16 cx)
{
	//画横线
	FillRect(x, y, cx, 1);
}

void DrawVertLine(s16 x, s16 y, s16 cy)
{
	//画竖线
	FillRect(x, y, 1, cy);
}

void DrawRect(s16 x, s16 y, s16 cx, s16 cy)		//x:[0,127]		y:[0,63]
{
	FillRect(x, y, cx, 1);
 	FillRect(x, y + cy - 1, cx, 1);
	FillRect(x, y, 1, cy);
	FillRect(x + cx - 1, y, 1, cy);
}

void DrawSmallChar(char c, s16 x, s16 y)
{
	if((c >= '0') && (c <= '9'))
	{
		DrawImage(&m_arrSmallNumber[(c-0x30)*14], x, y, 7, 14);
	}
//		else if(c == 'E')
//		{
//			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*5], x, y, 7, 14);		
//		}
	else if(c == '%')
	{
		DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*4], x, y, 7, 14);
	}
	else if(c == '.')
	{
		DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*3], x, y, 7, 14);
	}
	else if(c == '-')
	{
		DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*2], x, y, 7, 14);
	}
	else if(c == 't')
	{
		DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14], x, y, 7, 14);
	}
}

void DrawSmallText(char *sNum, s16 x, s16 y)
{
	int i, nLen;
	nLen = strlen(sNum);
	for(i = 0; i < nLen; i++)
	{
		if((sNum[i] >= '0') && (sNum[i] <= '9'))
		{
			DrawImage(&m_arrSmallNumber[(sNum[i]-0x30)*14], x + i*7, y, 7, 14);
		}
//		else if(sNum[i] == 'E')
//		{
//			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*5], x + i*7, y, 7, 14);		
//		}
		else if(sNum[i] == '%')
		{
			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*4], x + i*7, y, 7, 14);
		}
		else if(sNum[i] == '.')
		{
			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*3], x + i*7, y, 7, 14);
		}
		else if(sNum[i] == '-')
		{
			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14*2], x + i*7, y, 7, 14);
		}
		else if(sNum[i] == 't')
		{
			DrawImage(&m_arrSmallNumber[sizeof(m_arrSmallNumber)-14], x + i*7, y, 7, 14);
		}
	}
}

void DrawBigChar(char c, s16 x, s16 y)
{
    #if 0
	if(c == '.')
	{
		DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-108], x, y, 9, 18);
	}
	else if(c == '-')
	{
		DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-72], x, y, 9, 18);
	}
	else if(c == 't')
	{
		DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-36], x, y, 9, 18);
	}
	else if( (c >= '0') && (c <= '9'))
	{
		DrawImage(&m_arrBigNumber[(c-0x30)*36], x, y, 9, 18);
	}
    #else
	if(c == '.')
	{
		DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-180], x, y, 15, 30);
	}
	else if(c == '-')
	{
		DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-120], x, y, 15, 30);
	}
	else if(c == 't')
	{
		DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-60], x, y, 15, 30);
	}
	else if( (c >= '0') && (c <= '9'))
	{
		DrawImage(&m_arrBigNumber30[(c-0x30)*60], x, y, 15, 30);
	}
    #endif
}

void DrawBigText(char *sNum, s16 x, s16 y)
{
	int i, nLen;
	nLen = strlen(sNum);
    #if 0
	for(i = 0; i < nLen; i++)
	{
		if(sNum[i] == '.')
		{
			DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-108], x + i*9, y, 9, 18);
		}
		else if(sNum[i] == '-')
		{
			DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-72], x + i*9, y, 9, 18);
		}
		else if(sNum[i] == 't')
		{
			DrawImage(&m_arrBigNumber[sizeof(m_arrBigNumber)-36], x + i*9, y, 9, 18);
		}
		else if( (sNum[i] >= '0') && (sNum[i] <= '9'))
		{
			DrawImage(&m_arrBigNumber[(sNum[i]-0x30)*36], x + i*9, y, 9, 18);
		}
	}
    #else
	for(i = 0; i < nLen; i++)
	{
		if(sNum[i] == '.')
		{
			DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-180], x + i*15, y, 15, 30);
		}
		else if(sNum[i] == '-')
		{
			DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-120], x + i*15, y, 15, 30);
		}
		else if(sNum[i] == 't')
		{
			DrawImage(&m_arrBigNumber30[sizeof(m_arrBigNumber30)-60], x + i*15, y, 15, 30);
		}
		else if( (sNum[i] >= '0') && (sNum[i] <= '9'))
		{
			DrawImage(&m_arrBigNumber30[(sNum[i]-0x30)*60], x + i*15, y, 15, 30);
		}
	}
    #endif
}

#ifdef LCD_DEBUG

u8 dispBuf[128];
char *pTkn;

int LCD_Debug(void)
{
	int n;
	u8 cmd, nDataFlag = 0, nDataInHex = 0;
	memset(dispBuf, 0, 20);
	n = Usart3_RecvData(dispBuf, 128);
	if(n < 2)return dispBuf[0];

	pTkn = strtok((char*)dispBuf, ",");
	while(pTkn != NULL)
	{
		if(0 == memcmp(pTkn, "\r\n", 2))
		{
			nDataFlag = 1;
			pTkn += 2;
		}
		if(nDataFlag) 		
		{
			if(0 == memcmp(pTkn, "hex\0", 4))
			{
				nDataInHex = 1;
			}
			else if(nDataInHex)
			{
				BufferAsciiToHex(pTkn, &cmd, 2);
				LCD_WriteData(cmd);
				LCD_Delay(US_DLY(100));
			}
			else
			{
				while(*pTkn != 0)
				{
					LCD_WriteData(*pTkn++);
					LCD_Delay(US_DLY(100));
				}
			}
		}
		else
		{
			BufferAsciiToHex(pTkn, &cmd, 2);
			LCD_WriteCommand(cmd);
			LCD_Delay(US_DLY(100));
		}
		pTkn = strtok(NULL, ",");
	}
	return 0;
}
#endif


