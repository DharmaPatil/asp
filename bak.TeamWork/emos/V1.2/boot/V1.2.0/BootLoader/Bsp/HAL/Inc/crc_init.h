#ifndef _CRC_INIT_H_	
#define _CRC_INIT_H_

#ifdef __cplusplus		   //定义对CPP进行C处理 //开始部分
extern "C" {
#endif

#include "stm32f4xx.h"

//硬件CRC32
/****************************************************************************
* 名	称：void CRC32_init(void)
* 功	能：初始化硬件CRC32   
* 入口参数：无
* 出口参数：无
* 说	明：无
****************************************************************************/
void CRC32_init(void);
	
/****************************************************************************
* 名	称：u32 CRC32H_Chack8(const u8 flagC,u8 *pBuf, const u32 nSize)		  //取CRC32效验值
* 功	能：硬件CRC32效验	   
* 入口参数：const u8 flagC	是否清空CRC		0不复位	1复位
			u8 *pBuf 	进入8位数据
			const u32 nSize	数据个数
* 出口参数：32位的	CRC32效验码
* 说	明：进入的数据会累计计算CRC32效验码，CRC_ResetDR()为清空上次的效验码
****************************************************************************/
u32 CRC32H_Chack8(const u8 flagC,u8 *pBuf, const u32 nSize);

/****************************************************************************
* 名	称：u32 CRC32H_Chack32(const u8 flagC,u32* pBuf, const u32 nSize)		  //取CRC32效验值
* 功	能：硬件CRC32效验	   
* 入口参数：const u8 flagC	是否清空CRC		0不复位	1复位
			u32* pBuf 	进入32位的数据
			const u32 nSize	数据个数
* 出口参数：32位的	CRC32效验码
* 说	明：进入的数据会累计计算CRC32效验码，CRC_ResetDR()为清空上次的效验码
****************************************************************************/
u32 CRC32H_Chack32(const u8 flagC,u32* pBuf, const u32 nSize);

//软件CRC32
/****************************************************************************
* 名	称：void CRC32S_Clear(void)
* 功	能：复位软件CRC32值	   
* 入口参数：无
* 出口参数：无
* 说	明：无
****************************************************************************/
void CRC32S_Clear(void);

/****************************************************************************
* 名	称：u32 CRC32S_Chack8(const u8 flagC,u8* pBuf, const u32 nSize)		  //取CRC32效验值
* 功	能：软件CRC32效验
* 入口参数：const u8 flagC	是否清空CRC		0不复位	1复位
			u8* pBuf 	进入8位的数据
			const u32 nSize	数据个数
* 出口参数：32位的	CRC32效验码
* 说	明：CRC polynomial 0xedb88320
****************************************************************************/
u32 CRC32S_Chack8(const u8 flagC,u8* pBuf, const u32 nSize);

//软件CRC16
/****************************************************************************
* 名	称：u16 CRC16(const u8 flag,u8 *pData, const u32 nData)
* 功	能：CRC16效验
* 入口参数：const u8 flag		是否复位CRC16值		0不复位	1复位
			u8 *pData	多数据计算校验值
			const u32 nData	数据个数
* 出口参数：u16	CRC16校验值
* 说	明：每次自动复位校验值	
****************************************************************************/
u16 CRC16(const u8 flag,u8 *pData, const u32 nData);

/****************************************************************************
* 名	称：void CRC16_ResetDR(void)
* 功	能：CRC16效验值复位
* 入口参数：无
* 出口参数：无
* 说	明：清空CRC16值	
****************************************************************************/
void CRC16_ResetDR(void);

/****************************************************************************
* 名	称：void PushCrc16Byte(u8 nData)
* 功	能：CRC16效验
* 入口参数：u8 nData	单数据计算校验值
* 出口参数：无
* 说	明：一个数据计算校验值，不复位校验值
			一个数据计算完成后生成一个校验值，当把这个校验值在带入此函数中，正常结果会为0
****************************************************************************/
void PushCrc16Byte(const u8 nData);

/****************************************************************************
* 名	称：u16 GetCrcCode(void)
* 功	能：获取CRC16校验值并验证，验证通过返回0，验证失败返回非0
* 入口参数：无
* 出口参数：u16 验证通过返回0，验证失败返回非0
* 说	明：无	
****************************************************************************/
u16 GetCrc16Code(void);

#ifdef __cplusplus		   //定义对CPP进行C处理 //结束部分
}
#endif

#endif

/*
	//CRC32效验
	u8 x[3] = {23,55,23};
	u8 x1[3] = {23,55,99};
	u8 x2[3] = {23,55,23};
	u32 yh[3] = {0};		//8位数据硬件校验值

	u32 xx[3] = {123456,456789,123456};
	u32 xx1[3] = {123456,456789,123451};
	u32 xx2[3] = {123456,456789,123456};
	u32 yyh[3] = {0};		//32位数据硬件校验值

	u32 ys[3] = {0};		//软件校验值
	
	//CRC16效验
	u8 X[3] = {12,45,78};
	u16 Y = 0;
	u16 Y1 = 0;
	
	CRC32_init();				//初始化CRC32
	
	//8位数据硬件CRC32效验码单个生成
	yh[0] = CRC32H_Chack8(1,&x[0],1);
	yh[1] = CRC32H_Chack8(1,&x[1],1);
	yh[2] = CRC32H_Chack8(1,&x[2],1);	//yh[2] = yh[0]

	memset(yh,0,sizeof(yh));

	//8位数据硬件CRC32效验码多个生成
	yh[0] = CRC32H_Chack8(1,x,3);
	yh[1] = CRC32H_Chack8(1,x1,3);
	yh[2] = CRC32H_Chack8(1,x2,3);		//yh[2] = yh[0]

	//32位数据硬件CRC32效验码单个生成
	yyh[0] = CRC32H_Chack32(1,&xx[0],1);
	yyh[1] = CRC32H_Chack32(1,&xx[1],1);
	yyh[2] = CRC32H_Chack32(1,&xx[2],1);	//yyh[2] = yyh[0]

	memset(yyh,0,sizeof(yyh));

	//32位数据硬件CRC32效验码多个生成
	yyh[0] = CRC32H_Chack32(1,xx,3);
	yyh[1] = CRC32H_Chack32(1,xx1,3);
	yyh[2] = CRC32H_Chack32(1,xx2,3);		//yyh[2] = yyh[0]

	//8位数据软件CRC32效验码单个生成
	ys[0] = CRC32S_Chack8(1,&x[0],1);
	ys[1] = CRC32S_Chack8(1,&x[1],1);
	ys[2] = CRC32S_Chack8(1,&x[2],1);		//ys[2] = ys[0]

	memset(ys,0,sizeof(ys));

	//32位数据软件CRC32效验码多个生成
	ys[0] = CRC32S_Chack8(1,(u8*)&xx[0],4);
	ys[1] = CRC32S_Chack8(1,(u8*)&xx[1],4);
	ys[2] = CRC32S_Chack8(1,(u8*)&xx[2],4);		//ys[2] = ys[0]
	
	//16位数据软件CRC16效验码单个生成
	Y = CRC16(1,&X[0],1);
	Y = CRC16(0,&X[1],1);
	Y = CRC16(0,&X[2],1);

	//16位数据软件CRC16效验码多个生成
	Y1 = CRC16(1,X,3);	
*/
